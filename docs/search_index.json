[
["index.html", "The evolution of information centres at aggregation sites Section 1 Introduction 1.1 Attribution 1.2 Data access 1.3 Data processing", " The evolution of information centres at aggregation sites Pratik R Gupte 2020-04-15 Section 1 Introduction This is the bookdown version of a project in preparation that links high-resolution tracking data from individual red knots Calidris canutus islandica to fine-scale experimental behaviour measurements in captivity, and examines whether individuals are consistent across scales in their space-use. 1.1 Attribution Pratik Gupte (author and maintainer) PhD student, GELIFES – University of Groningen Guest researcher, COS – NIOZ p.r.gupte@rug.nl Nijenborgh 7/5172.0583 9747AG Groningen 1.2 Data access The data used in this work are generated using the C++ code in this repository. 1.3 Data processing The data processing for this project is described in the following sections. Navigate through them using the links in the sidebar. "],
["run-infomove-on-the-cluster.html", "Section 2 Run Infomove on the cluster 2.1 Prepare libraries 2.2 Prepare infomove v02 on Peregrine 2.3 Remove old data 2.4 Run infomove", " Section 2 Run Infomove on the cluster 2.1 Prepare libraries Libs remain the same in R. # load libs library(tidyverse) library(ssh) library(glue) 2.2 Prepare infomove v02 on Peregrine Leader choice limits are now included in the master branch. D is not allowed to evolve, and is forced to 1.0 to promote switching/following. # read peregrine password password = read_lines(&quot;private/password.txt&quot;) # connect to cluster and pull from master s &lt;- ssh_connect(&quot;p284074@peregrine.hpc.rug.nl&quot;, passwd = password) ssh_exec_wait(s, command = c(&quot;cd infomove/&quot;, &quot;rm Makefile infomove&quot;, &quot;cd jobs&quot;, &quot;rm *.sh&quot;, &quot;rm *.out&quot;, &quot;cd ..&quot;, &quot;git pull&quot;, &quot;git checkout master&quot;, # checkout master branch &quot;ml load GCC/8.3.0&quot;, &quot;ml load GSL/2.6-GCC-8.3.0&quot;, &quot;qmake infomove.pro&quot;, &quot;make clean -j4&quot;, &quot;make -j4&quot;)) 2.3 Remove old data { ssh_exec_wait(s, c(&quot;cd infomove/data&quot;, &#39;find . -name &quot;*.csv&quot; -type f -delete&#39;)) } 2.4 Run infomove # read job shebang shebang &lt;- readLines(&quot;code_analysis/template_job.sh&quot;) { type = c(&quot;info&quot;) phi = c(5, 25, 50, 100) rho = 0.1 gens = &quot;50000&quot; # a test case timesteps = 100 init_d = c(1.0) n_lead = c(1,2,5) replicate = 1:5 } sim_params &lt;- crossing(type, phi, rho, gens, timesteps, init_d, n_lead, replicate) # send commands pwalk(sim_params, function(type, phi, rho, gens, timesteps, init_d, n_lead, replicate){ if(!dir.exists(&quot;jobs&quot;)){ dir.create(&quot;jobs&quot;) } shebang[2] &lt;- glue(&#39;#SBATCH --job-name=run_infomove_type-{type}_phi{phi}_nlead{n_lead}_rep{replicate}&#39;) { command &lt;- glue(&#39;./infomove {type} {phi} {rho} {gens} {timesteps} {init_d} {n_lead} {replicate}&#39;) jobfile &lt;- glue(&#39;job_infomove_type{type}_phi{phi}_nlead{n_lead}_rep{replicate}.sh&#39;) writeLines(c(shebang, command), con = glue(&#39;jobs/{jobfile}&#39;)) scp_upload(s, glue(&#39;jobs/{jobfile}&#39;), to = &quot;infomove/jobs/&quot;) file.remove(glue(&#39;jobs/{jobfile}&#39;)) } # run jobs; we are in infomove ssh_exec_wait(s, command = c(&quot;cd infomove/jobs&quot;, glue(&#39;dos2unix {jobfile}&#39;), glue(&#39;sbatch {jobfile}&#39;))) }) # move into jobs, delete scripts and disconnect ssh_exec_wait(s, command = c(&quot;cd infomove/jobs&quot;, &quot;rm *.sh *.out&quot;, &quot;cd ..&quot;)) ssh_disconnect(s) "],
["run-an-infomove-variant-on-the-cluster.html", "Section 3 Run an Infomove variant on the cluster 3.1 Prepare libraries 3.2 Prepare infomove v03 on Peregrine 3.3 Remove old data 3.4 Run infomove", " Section 3 Run an Infomove variant on the cluster In this version, the evolved parameter D (aspiration) is also allowed to evolve. 3.1 Prepare libraries Libs remain the same in R. # load libs library(tidyverse) library(ssh) library(glue) 3.2 Prepare infomove v03 on Peregrine Check out the allow_D branch on the cluster. # read peregrine password password = read_lines(&quot;private/password.txt&quot;) # connect to cluster and pull from master s &lt;- ssh_connect(&quot;p284074@peregrine.hpc.rug.nl&quot;, passwd = password) ssh_exec_wait(s, command = c(&quot;cd infomove/&quot;, &quot;rm Makefile infomove&quot;, &quot;cd jobs&quot;, &quot;rm *.sh&quot;, &quot;rm *.out&quot;, &quot;cd ..&quot;, &quot;git pull&quot;, &quot;git checkout allow_D&quot;, # checkout the allow_D branch &quot;ml load GCC/8.3.0&quot;, &quot;ml load GSL/2.6-GCC-8.3.0&quot;, &quot;qmake infomove.pro&quot;, &quot;make clean -j4&quot;, &quot;make -j4&quot;)) 3.3 Remove old data { ssh_exec_wait(s, c(&quot;cd infomove/data&quot;, &#39;find . -name &quot;*.csv&quot; -type f -delete&#39;)) } 3.4 Run infomove # read job shebang shebang &lt;- readLines(&quot;code_analysis/template_job.sh&quot;) { type = c(&quot;info&quot;, &quot;noinfo&quot;) phi = c(5, 25, 50, 100) rho = 0.1 gens = &quot;50000&quot; # a test case timesteps = 100 init_d = c(0.5) # D init at 0.5, unlike 1.0 to force following/switching n_lead = c(1,2,5) replicate = 1:5 } sim_params &lt;- crossing(type, phi, rho, gens, timesteps, init_d, n_lead, replicate) # send commands pwalk(sim_params, function(type, phi, rho, gens, timesteps, init_d, n_lead, replicate){ if(!dir.exists(&quot;jobs&quot;)){ dir.create(&quot;jobs&quot;) } shebang[2] &lt;- glue(&#39;#SBATCH --job-name=run_infomove_type-{type}_phi{phi}_nlead{n_lead}_rep{replicate}&#39;) { command &lt;- glue(&#39;./infomove {type} {phi} {rho} {gens} {timesteps} {init_d} {n_lead} {replicate}&#39;) jobfile &lt;- glue(&#39;job_infomove_type{type}_phi{phi}_nlead{n_lead}_rep{replicate}.sh&#39;) writeLines(c(shebang, command), con = glue(&#39;jobs/{jobfile}&#39;)) scp_upload(s, glue(&#39;jobs/{jobfile}&#39;), to = &quot;infomove/jobs/&quot;) file.remove(glue(&#39;jobs/{jobfile}&#39;)) } # run jobs; we are in infomove ssh_exec_wait(s, command = c(&quot;cd infomove/jobs&quot;, glue(&#39;dos2unix {jobfile}&#39;), glue(&#39;sbatch {jobfile}&#39;))) }) # move into jobs, delete scripts and disconnect ssh_exec_wait(s, command = c(&quot;cd infomove/jobs&quot;, &quot;rm *.sh *.out&quot;, &quot;cd ..&quot;)) ssh_disconnect(s) "],
["visualise-evolved-parameters.html", "Section 4 Visualise evolved parameters 4.1 Load libraries 4.2 Get data from cluster 4.3 Plot parameter means over time 4.4 Plot mean response curve", " Section 4 Visualise evolved parameters Visualise the evolved parameters in increments of 1000 generations, for each simulation run, grouping by parameter combination and replicate. Then, plot the probability of following, given by \\[p = 1/(1 + e^{-b(-\\Delta Q - a)}) \\] 4.1 Load libraries # data libraries library(readr) library(dplyr) library(purrr) library(glue) library(tidyr) library(ssh) # plotting library(ggplot2) library(patchwork) # function for prob follow deltaq = seq(-2, 2, 0.2) prob_follow &lt;- function(a,b,q = deltaq){1 / (1 + exp(-b*q -a))} 4.2 Get data from cluster # use infomover library(infomover) password = read_lines(&quot;private/password.txt&quot;) get_summary(ssh_con = &quot;p284074@peregrine.hpc.rug.nl&quot;, password = password, type = c(&quot;all&quot;)) 4.3 Plot parameter means over time 4.3.1 Read data # find data data_files &lt;- list.files(&quot;data&quot;, pattern = &quot;data_global_summary&quot;, recursive = TRUE, full.names = TRUE) # read data data &lt;- map(data_files, read_csv) 4.3.2 Plot data data &lt;- map(data, function(df){ df &lt;- filter(df, parameter != &quot;M&quot;) df &lt;- split(df, df$phi) %&gt;% map(function(df2){split(df2, df2$leader_choices)}) }) walk2(data, c(&quot;info&quot;, &quot;noinfo&quot;), function(x,y){ a_fig = map2(x, names(x), function(df_list, name){ title = glue::glue(&#39;Φ (number of peaks): {name}, simulation type: {y}, M evolving with costs&#39;) fig_subpanel &lt;- map2(df_list, names(df_list), function(df, name2){ subtitle = glue::glue(&#39;leader choices: {name2}&#39;) fig_param &lt;- ggplot(data = df, aes(x=gen, y=mean, ymin=mean-sd, ymax=mean+sd, col = parameter, fill = parameter, group = parameter))+ #geom_pointrange(size = 0.1)+ geom_hline(yintercept = c(0,1), size = 0.1, col = &quot;grey&quot;, lty = 3)+ geom_ribbon(alpha = 0.3, col = NA, fill = &quot;grey&quot;)+ geom_line(size = 0.3, alpha = 0.9)+ scale_colour_brewer(palette = &quot;Set1&quot;)+ # scale_fill_viridis_c(option = &quot;E&quot;, limits = c(0, 250), # na.value = &quot;steelblue&quot;, direction = -1)+ scale_x_continuous(breaks = c(0,50000,100000), labels = as.character(c(0, 50, 100)))+ # scale_y_continuous(breaks = c(0,0.5,1), # labels = c(0, 0.5, 1))+ theme_minimal(base_size = 5)+ theme(plot.background = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.grid = element_blank(), axis.title = element_text(), # plot.title = element_text(face = &quot;bold&quot;), legend.position = &quot;none&quot;, axis.text.y = element_text(angle = 0))+ # coord_cartesian(expand = T, ylim =c(0,1))+ facet_grid(parameter~rep,labeller = label_both, scales = &quot;free_y&quot;)+ labs(x = NULL, y = NULL, title = subtitle) }) fig_param &lt;- wrap_plots(fig_subpanel, guides = &quot;collect&quot;, ncol = 3)+ plot_annotation(title = title, theme = theme(plot.title = element_text(size = 6))) return(fig_param) }) cairo_pdf(file = glue(&#39;figs/fig_v5_{y}_param_trajectory.pdf&#39;), width = 10, height = 3, onefile = TRUE) { print(a_fig) } dev.off() }) 4.4 Plot mean response curve 4.4.1 Prepare data # read in data again data &lt;- map(data_files, read_csv) # remove D, F, M data &lt;- map(data, function(df){ df &lt;- filter(df, parameter %in% c(&quot;a&quot;, &quot;b&quot;)) %&gt;% pivot_wider(names_from = &quot;parameter&quot;, values_from = c(&quot;mean&quot;, &quot;sd&quot;)) }) # split by phi and then by leader choices data &lt;- map(data, function(df){ df &lt;- split(df, df$phi) %&gt;% map(function(df2){split(df2, df2$leader_choices) %&gt;% map(function(df3){ df3 &lt;- select(df3, type, phi, leader_choices, rep, gen, mean_a, mean_b, sd_a, sd_b) %&gt;% filter(gen &gt; 0 &amp; gen %% 2000 == 0) %&gt;% mutate(resp = pmap(list(mean_a, mean_b, sd_a, sd_b), function(mean_a, mean_b, sd_a, sd_b){ return(tibble(deltaq = deltaq, pf = prob_follow(mean_a,mean_b,deltaq), pf_low = prob_follow(mean_a-sd_a, mean_b-sd_b,deltaq), pf_high = prob_follow(mean_a+sd_a, mean_b+sd_b,deltaq))) })) %&gt;% unnest(cols = resp) })}) }) 4.4.2 Plot figure walk2(data, c(&quot;info&quot;, &quot;noinfo&quot;), function(x,y){ a_fig = map2(x, names(x), function(df_list, name){ title = glue::glue(&#39;Φ (number of peaks): {name}, simulation type: {y}, M evolving with costs&#39;) fig_subpanel &lt;- map2(df_list, names(df_list), function(df, name2){ subtitle = glue::glue(&#39;leader choices: {name2}&#39;) fig_resp &lt;- ggplot(df)+ geom_vline(xintercept = 0, lwd = 0.1, lty = 3)+ geom_ribbon(aes(x = deltaq, ymin = pf_low, ymax = pf_high, group = rep), alpha = 0.2)+ geom_path(aes(deltaq, pf, group = rep, col = deltaq &lt; 0), size = 0.1)+ facet_wrap(~gen, ncol = 8)+ scale_colour_brewer(palette = &quot;Set1&quot;, direction = -1)+ scale_x_continuous(breaks = c(-10, 0, 10))+ scale_y_continuous(breaks = c(0, 0.5, 1))+ coord_cartesian(ylim = c(0,1), expand = T)+ theme_minimal(base_size = 5)+ theme(plot.background = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.grid = element_blank(), axis.title = element_text(), # plot.title = element_text(face = &quot;bold&quot;), legend.position = &quot;none&quot;, axis.text.y = element_text(angle = 90))+ labs(x = NULL, y = NULL, title = subtitle) }) fig_param &lt;- wrap_plots(fig_subpanel, guides = &quot;collect&quot;, ncol = 3)+ plot_annotation(title = title, theme = theme(plot.title = element_text(size = 6))) return(fig_param) }) cairo_pdf(file = glue(&#39;figs/fig_v5_{y}_follow_prob.pdf&#39;), width = 10, height = 3, onefile = TRUE) { print(a_fig) } dev.off() }) "],
["heatmaps-evolved-parameters.html", "Section 5 Heatmaps evolved parameters 5.1 Load libraries 5.2 Plot parameter counts over time", " Section 5 Heatmaps evolved parameters Visualise the evolved parameters in increments of 1000 generations as heatmaps. 5.1 Load libraries # data libraries library(readr) library(dplyr) library(purrr) library(glue) library(tidyr) # plotting library(ggplot2) library(patchwork) library(scico) 5.2 Plot parameter counts over time 5.2.1 Read data # find data data_files &lt;- list.files(&quot;data&quot;, pattern = &quot;data_global_counts&quot;, recursive = TRUE, full.names = TRUE) # read data data &lt;- map(data_files, read_csv) # split data data &lt;- map(data, function(df){ df &lt;- filter(df, variable %in% c(&quot;a&quot;, &quot;b&quot;, &quot;D&quot;, &quot;M&quot;, &quot;pf&quot;), gen %% 4000 == 0) df &lt;- split(df, df$phi) %&gt;% map(function(df2){split(df2, df2$leader_choices)}) }) 5.2.2 Plot data # plot as heatmap walk2(data, c(&quot;info&quot;, &quot;noinfo&quot;), function(x,y){ a_fig = map2(x, names(x), function(df_list, name){ title = glue::glue(&#39;Φ (number of peaks): {name}, simulation type: {y}, M evolving with costs&#39;) fig_subpanel &lt;- map2(df_list, names(df_list), function(df, name2){ subtitle = glue::glue(&#39;leader choices: {name2}&#39;) fig_param &lt;- ggplot(data = df, aes(x=gen, y=round_value, fill=count))+ geom_hline(yintercept = c(0,1), size = 0.1, col = &quot;grey&quot;, lty = 3)+ geom_tile()+ scale_fill_viridis_c(option = &quot;E&quot;, limits = c(0, 250), na.value = &quot;indianred1&quot;, direction = 1)+ scale_x_continuous(breaks = c(0,50000,100000), labels = as.character(c(0, 50, 100)))+ # scale_y_continuous(breaks = c(0,0.5,1), # labels = c(0, 0.5, 1))+ theme_grey(base_size = 5)+ theme(plot.background = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.grid = element_blank(), axis.title = element_text(), # plot.title = element_text(face = &quot;bold&quot;), legend.position = &quot;right&quot;, legend.key.width = unit(1, &quot;mm&quot;), axis.text.y = element_text(angle = 0))+ # coord_cartesian(expand = T, ylim =c(0,1))+ facet_grid(variable~rep,labeller = label_both, scales = &quot;free_y&quot;)+ labs(x = NULL, y = NULL, title = subtitle) }) fig_param &lt;- wrap_plots(fig_subpanel, guides = &quot;collect&quot;, ncol = 3)+ plot_annotation(title = title, theme = theme(plot.title = element_text(size = 6))) return(fig_param) }) cairo_pdf(file = glue(&#39;figs/fig_v5_{y}_param_count.pdf&#39;), width = 10, height = 3, onefile = TRUE) { print(a_fig) } dev.off() }) "],
["plot-parameter-combinations.html", "Section 6 Plot parameter combinations 6.1 Load libraries 6.2 Plot parameter counts over time", " Section 6 Plot parameter combinations Visualise the evolved parameters in increments of 1000 generations as heatmaps. 6.1 Load libraries # data libraries library(readr) library(dplyr) library(purrr) library(glue) library(tidyr) # plotting library(ggplot2) library(patchwork) library(scico) 6.2 Plot parameter counts over time 6.2.1 Read data # find data data_files &lt;- list.files(&quot;data&quot;, pattern = &quot;data_phenotype_counts&quot;, recursive = TRUE, full.names = TRUE) # read data data &lt;- map(data_files, read_csv) # split data data &lt;- map(data, function(df){ df &lt;- filter(df, gen %% 4000 == 0) %&gt;% mutate(a = round(a), b = round(b)) %&gt;% group_by(gen, rep, a, b, phi, leader_choices) %&gt;% summarise(n = length(mean_f), mean_f = mean(mean_f), sd_f = mean(sd_f)) df &lt;- split(df, df$phi) %&gt;% map(function(df2){split(df2, df2$leader_choices)}) }) 6.2.2 Plot data # plot as heatmap walk2(data, c(&quot;info&quot;, &quot;noinfo&quot;), function(x,y){ a_fig = map2(x, names(x), function(df_list, name){ title = glue::glue(&#39;Φ (number of peaks): {name}, simulation type: {y}&#39;) fig_subpanel &lt;- map2(df_list, names(df_list), function(df, name2){ subtitle = glue::glue(&#39;leader choices: {name2}&#39;) fig_param &lt;- ggplot(data = df, aes(x=a, y=b, col = mean_f))+ geom_hline(yintercept = c(0), size = 0.1, col = &quot;grey&quot;, lty = 3)+ geom_vline(xintercept = c(0), size = 0.1, col = &quot;grey&quot;, lty = 3)+ geom_point(size = 1, alpha = 0.6, shape = 16)+ scale_colour_distiller(palette = &quot;YlOrRd&quot;, direction = 1)+ # scale_x_continuous(breaks = c(0,50000,100000), # labels = as.character(c(0, 50, 100)))+ # scale_y_continuous(breaks = c(0,0.5,1), # labels = c(0, 0.5, 1))+ theme_grey(base_size = 5)+ theme(plot.background = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.border = element_rect(colour = &quot;black&quot;, fill=NA, size = 0.2), panel.grid = element_blank(), axis.title = element_text(), # plot.title = element_text(face = &quot;bold&quot;), legend.position = &quot;right&quot;, legend.key.width = unit(1, &quot;mm&quot;), axis.text.y = element_text(angle = 0))+ # coord_cartesian(expand = T, ylim =c(0,1))+ facet_grid(rep~gen,labeller = label_both, scales = &quot;fixed&quot;)+ labs(x = NULL, y = NULL, title = subtitle) }) fig_param &lt;- wrap_plots(fig_subpanel, guides = &quot;collect&quot;, ncol = 1)+ plot_annotation(title = title, theme = theme(plot.title = element_text(size = 6))) return(fig_param) }) cairo_pdf(file = glue(&#39;figs/fig_v2_{y}_phenotype_count.pdf&#39;), width = 12, height = 12, onefile = TRUE) { print(a_fig) } dev.off() }) "]
]
